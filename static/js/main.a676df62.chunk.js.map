{"version":3,"sources":["components/UI/Card.js","components/Expenses/ExpensesFilter.js","components/Expenses/ExpenseDate.js","components/Expenses/ExpenseItem.js","components/Expenses/ExpensesList.js","components/Chart/ChartBar.js","components/Chart/Chart.js","components/Expenses/ExpensesChart.js","components/Expenses/Expenses.js","components/NewExpense/ExpenseForm.js","components/NewExpense/NewExpense.js","App.js","index.js"],"names":["Card","props","classes","className","children","ExpensesFilter","value","selected","onChange","event","onChangeFiltered","target","ExpenseDate","month","date","toLocaleString","day","year","getFullYear","ExpenseItem","title","amount","ExpensesList","items","length","map","expense","id","ChartBar","barFillHeight","maxValue","Math","round","style","height","label","Chart","dataPointValues","dataPoints","dataPoint","totalMaximum","max","ExpensesChart","chartDataPoints","expenses","getMonth","Expenses","useState","filteredYear","setFilteredYear","filteredExpenses","filter","toString","selectedYear","ExpenseForm","eneteredTitle","setEnteredTitle","eneteredAmount","setEnteredAmount","eneteredDate","setEnteredDate","onSubmit","preventDefault","expenseData","Date","onSaveExpenseData","type","min","step","onClick","onCancel","NewExpense","isEdiiting","setIsEditing","eneteredExpenseData","random","onAddExpense","Dummy_expenses","App","setExpenses","prevExpenses","ReactDOM","createRoot","document","getElementById","render"],"mappings":"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","file":"static/js/main.a676df62.chunk.js","sourcesContent":["import './Card.css';\r\n/* Card.js typically means some kind of container look with rounded corners and drop shadows */\r\n/* Our Card component is still a regular component so we will have a function named Card. Such  Card componenet could do one main thing, it could return a div or any other kind of html element with a className of Card and then we\r\ncould add a Card.css file and import that into this Card component (Card.js)  \r\nconst Card = (props) => {    here we accept props \r\n  \r\n  return <div className=\"card\">{props.children}</div>;  This should act as a shell around either our ExpenseItem content or our Expenses content.\r\n                                           Our special prop value we will output between the opening and closing tag of our div (inside of our Card component function), and that would be props.children. children is a reserved name and\r\n                                          the value of this special children prop will always be the content between the opening and closing custom tags of our custom compoenet (in this case our Card component tags in ExpenseItem.js).\r\n                                          So in our case the content between the opening and closing tags in ExpenseItem.js file will be avaiable on props.children inside of that card \r\n                                          \r\n}\r\n We would tweek this code above, such that we add whatever is set as className on our Card component tag in ExpenseItem.js, to this className string \"card\", we're setting as a className on that div  */\r\n\r\nconst Card = (props) => {   /* here we accept props */\r\n  const classes = 'card ' + props.className; /* So here we could add a classes constant which is 'card ' which is a deafult class which is always applied, white-space + props.className. So anything we recieve as a className from outside is \r\n                                                 added to that string 'card'. So with this we are making sure that any value set on the className prop is added to this long string of classNames which is then finally set on the div below inside\r\n                                                of this Card */\r\n  return <div className={classes}>{props.children}</div>; /* here we can dynamically point to our classes constant {classes} */\r\n\r\n}\r\n\r\n/* What did we gain from this ?\r\nWe'll ni this case we didnt gain much however  we did seperate some code duplicaion inside of our css files into the seperate wrapper component. It's not only this we also were able to estract this\r\nJSX code on line 19 of this file. In this case its just one div but throughout this course we will also see more complex wrapper components which may have a more complex JSX structure things like\r\nmodels and alerts and in such cases being able to extract that aloows you to save alot of code duplication and keeps other components clean.\r\nThis is another aspect of composition. We compose our expense item component by using <Card></Card> as a wrapper in ExpenseItem.js with content in the middle of it and all these components and elements \r\nare composed together to form the overall ExpenseItem component which then again is used in other components which overall bulds the userinterface. Whenever you combine components you are using composition.\r\nprops.children is a special type of component which allows you to create a wrapper component  */\r\nexport default Card;","import React from 'react';\r\n\r\nimport './ExpensesFilter.css';\r\n\r\nconst ExpensesFilter = props => {\r\n  const dropdownChangeHandler = event => {\r\n    props.onChangeFiltered(event.target.value);\r\n  };\r\n\r\n  return (\r\n    <div className='expenses-filter'>\r\n      <div className='expenses-filter__control'>\r\n        <label>Filter by year</label>\r\n        <select value={props.selected} onChange={dropdownChangeHandler}>\r\n          <option value='2022'>2022</option>\r\n          <option value='2021'>2021</option>\r\n          <option value='2020'>2020</option>\r\n          <option value='2019'>2019</option>\r\n        </select>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ExpensesFilter;","import './ExpenseDate.css';\r\n\r\nconst ExpenseDate = (props) => {\r\n  const month = props.date.toLocaleString('en-GB', { month: 'long' }); \r\n  const day = props.date.toLocaleString('en-GB', { day: '2-digit' });\r\n  const year = props.date.getFullYear();\r\n\r\n  return (\r\n    <div className=\"expense-date\">\r\n      <div className=\"expense-date__month\">{month}</div> {/* we are just pointing at the month variable */}\r\n      <div className=\"expense-date__year\">{year}</div>\r\n      <div className=\"expense-date__day\">{day}</div>\r\n  </div>\r\n  );\r\n }\r\nexport default ExpenseDate; // we export it to make it reusable outside of this file","/* import React, { useState } from 'react';   between the {} we can now extract spesifically named things from the React libary. import React imports the overall React object and inside {} we want to import single peices from the React libary. using {useState} allows us to define\r\n                                  values as states where changes to these values should reflect in the component function being called again which is a key differance to the regular vairbale which we use: let title = props.title; (line 110)*/\r\nimport ExpenseDate from './ExpenseDate'; /* We say import ExpenseDate as we are refering to a component and then we say from (the path...) */\r\nimport Card from '../UI/Card'; /* So here we use ../ as we are ging up one level (out of the Expense folder and into the other sub folder of the compoement folder which would be the UI folder) */\r\nimport './ExpenseItem.css'; /* We import like this as the ExpenseItem.css file is in the same folder as this ExpenseItem.js component (./) and it's just a css file.\r\n                               This tells the build process this css file should be considered.\r\n                               Inside of this css file we preapred a bunch of css classes which can be added to elements to add a certain look and therefore in our JSX code in our ExpenseItem function in this ExpenseItem.js component we need to\r\n                               add these classes.\r\nWe dont type class inside our div like regular html: <div class-\"\"></div>; we type className: <div className=\"\"></div>; as this is the JSX syntax  */\r\n/*const ExpenseItem = () => {\r\n      return (\r\n      <div className=\"expense-item\">\r\n        <div>March 28th</div>\r\n        <div className=\"expense-item__description\">\r\n          <h2>Car Insurance</h2>\r\n          <div className=\"expense-item__price\">Â£243.45</div>\r\n        </div>\r\n      </div>\r\n      );\r\n    } \r\n\r\n  the code above is hard coded which we dont want. To output special data React uses a speical syntax inside of the JSX code snippets and that would be {}. Inside of these {} you can run js expressions*/\r\n\r\n/* We can make our components reusable by using prameters and a concept called props in react, where we can pass data to the custom component by adding a attribute and inside of that component we can get access to all these attributes which\r\nmight have been set on our custom component. We are basically building our own custom html elements and just as html elements can have attributes it turns out with react are own custom components can also have attributes there this concept is\r\ncalled props (this stands for properties) instead of atributes. So we can set properties in our own custom components */\r\n\r\n/* Now the missing half after coding our custom elements (ExpenseItem) in the App.js file, we would need to use paramters in our function ExpenseIten below. We would use one paramter as React would ensurethat we get one parameter in every component \r\nwhich we use as a component similar to what we did to the ExpenseItem elements (line 38 - line 53) and that one paramter will be an object that holds all the recieved attributes as properties hence the name  Therefore we get one parameter which \r\nyou can name it whatever you want but typically it's named props to make it clear that this is the object which holds all the values that we get from the attributes on our custom elements ExpenseItem in App.js file. to be procise we get key value pairs\r\nin the props object which is passed in by React automatically. The keys would be the attribute names in our custom elements ExpenseItem in App.js file (so title, amount, date) and the values would be the values that we set to these keys.\r\n\r\nIMPORTANT: (props) is the same as ({amount, data, title}) and typically it's better to deconstuct our prop so that in our JSX code we dont have to write {props.title} for example, we can just write {title} (But for this course we will stick with (props) to make things easier) \r\n\r\nconst ExpenseItem = ({amount, date, title}) => {\r\n  const month = date.toLocaleString('en-GB', { month: 'long' });  This is considered better practice if we dont put our logic like this in our JSX code but instead we create a seperate variable/ constant. \r\n  const day = date.toLocaleString('en-GB', { day: '2-digit' });\r\n  const year = date.getFullYear();\r\n\r\n   JSX code below \r\n   return (\r\n     <div className=\"expense-item\">\r\n        <div>\r\n          <div>{month}</div>  we are just pointing at the month variable \r\n          <div>{year}</div>\r\n          <div>{day}</div>\r\n        </div>\r\n        <div className=\"expense-item__description\">\r\n          <h2>{title}</h2>  we do this to output the title recieved in this h2 tag. So we are getting access to our props paramter and then picking the title which will exist as we set title attributes in App.js \r\n          <div className=\"expense-item__price\">{amount}</div>\r\n        </div>\r\n     </div>\r\n     );\r\n   }\r\n So the in the above code we are now getting all the data from outside that code. We are not defning anything inside the ExpenseItem function (component) but instead it is defined in App.js and passed into ExpenseItem for the different usages of ExpenseItem\r\nthrough attributes and this is how you share data between React components. \r\nYou can make your components truly reusable and configurable by using this props concept which is one of the key concepts Reacts has to offer. \r\n\r\n\r\n\r\nconst ExpenseItem = (props) => {\r\n\r\n  JSX code below \r\n   return (\r\n     <div className=\"expense-item\">\r\n        <ExpenseDate date={props.date}/> If you have a component that has no content between the opening and closing tags like: <ExpenseDate></ExpenseDate> we can write it like we have, a self closing element. We're doing this to move some of the JSX code and js logic out \r\n                                       of the ExpenseItem and into a seperate component which we named ExpenseDate.js. Now our JSX code is shorter and is easy to manage.\r\n                                       Using <ExpenseDate date={date}>, we are now funneling some data through multiple levels of components.\r\n                                       So now we can visulise our component tree as now we dont just have the App component we have multiple custom components and they are nested inside of eachother. To make things clear, in the App component we are using the ExpenseItem component \r\n                                       and inside of the ExpenseItem component we are using the ExpenseDate component and not just that we are also forwarding our data with the help of props through multiple components. We're passing data from the App component into ExpenseItem and\r\n                                       in our ExpenseItem component we are outputting some of the data but other parts of the data (the date) which we already recieved through props is then forwarded even further into the ExpenseDate component again by using props (date={date}),\r\n                                       becuase props are our way of passing data from component A to component B. So our props pass data from a component to a direct child component. \r\n        <div className=\"expense-item__description\">\r\n          <h2>{props.title}</h2> \r\n          <div className=\"expense-item__price\">{props.amount}</div>\r\n        </div>\r\n     </div>\r\n     );\r\n   }\r\n   \r\n\r\n   const ExpenseItem = (props) => {\r\n\r\n     JSX code below \r\n     return (\r\n       <Card className=\"expense-item\">     We can replace the div in this line with our custom Card component which we would get our predefinded styles in css.js automatically. However you cant just use your custom componenets as wrapers\r\n                                           around other content like a div. Having content inbetween opening and closing tags doesnt work just like that but ofcourse it does work for built in html elements like a div. We can make our\r\n                                           custom Card component work like this by accepting props in our Card.js file (Card component) but now we wont work with some attributes but instead we will use one special prop which is built\r\n                                           into React which every component recieves even if youre never setting it explicitly (look on our Card.js file for further explanation.\r\n                                           Our code still wont be fully function as our default html compoenents (div etc.) out of the box support className for adding css class to the rendered html elements, but our custome components like our Card component \r\n                                           only support what you tell them to support so if you want to make sure a className can be set on your Card component and then has an affect we will hav to tweek the code in the Card component (look at Card.js file \r\n                                           for the tweek). \r\n          <ExpenseDate date={props.date} /> \r\n          <div className=\"expense-item__description\">\r\n            <h2>{props.title}</h2> \r\n            <div className=\"expense-item__price\">{props.amount}</div>\r\n          </div>\r\n       </Card>\r\n       );\r\n     }\r\n*/\r\n\r\n\r\n\r\n/* Section 4 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n     const ExpenseItem = (props) => {\r\n   /*   const [title, setTitle] = useState(props.title);               Inside of our component function we just need to call useState to use states and useState is a React-hook. There are many differant hooks and all these React-hooks can be recognised by the fact that they start with the word use in their name\r\n                                  and all these hook must be caled inside of React component functions like ExpenseItem (so they can not be called inside of a nested function or outside our function components).\r\n                                  However useState() doesnt work just like this as useState(); wants a default state value becuase with this we create a special kind of variable, a variable where it'll lead our EcpenseItem component function to be called again anf therefore we can \r\n                                  assign an initial value for that special variable to that.\r\n                                  \r\n                                  Our intial value is props.title which we have done below and we set this into our useState(). Now our special vairbale is created: useState(props.title); and now we want to use this variable in our h2 tag for example and therefore useState will\r\n                                  return somthing, it gives us access to this special variable however it doesnt just return that, it also returns a function which we can call to assign a new value to that variable, so we wont be assigning values like we did: title = 'updated'; with the\r\n                                  equal sign instead we will be assigning new values by calling a function, that is just how the state vairable works. useState actually returns an array where the first value is the variable itself and the second element in the array is the updating \r\n                                  function and we can use array destructering which look like: const [] = useState(props.title); to store both elements in seperate variables or constants.\r\n                                  We can call our elements anything we like as it's just the order that matters (convention is to name the first element in accordance to the managed value and the second element with 'set' at the start with the first element followed e.g. [title, setTitle]). \r\n                                  Let's name them [title, setTitle]. So the first element, title is just a pointer at the managed value (the value stored in props.title) and the second element setTitle is a function which we can later call to set a new title (update the title). \r\n                                  \r\n                                  We are using const here eventhough we ressaign a new value with the state updtaing function: setTitle('updated'). We arent using an equal sign when updating our state as this is not how we update a state. By calling useState() we are telling React that it should manage some \r\n                                  value for us which we never see itself therefore we just call our state updating function and then using const is fine.*/\r\n\r\n\r\n\r\n\r\n/*    let title = props.title;     We have a scenario where we want to use the built in state concept, as this title here whih changed when the clickHandler executes is actually data that should result in the component (the JSX code after the return and before the button element)\r\n                                   re-evaluated and redrawn on the screen when the title data changed.\r\n                                   After the inital rendering the current our ExpenseItem component function) is not called a second time after the inital rendering. Just becuase a variable changed (in our case after the click the title will change into 'updated')\r\n                                   dpesnt mean it'll render again.\r\n                                   So to tell React that it should run it again we need to import something from the React libary and we do this by using import React, {} from 'react';*/\r\n\r\n   /*   const clickHandler = () => {\r\n        setTitle('updated');                  We are setting a new title by calling our state updating function: setTile(); and then we just pass the new value as an argument: setTitle('updated');  \r\n                                              Using this state updating function, we are telling React we want to assign a new value to this state and that then tells React the component in which the state was registured in with useState: const [title, setTitle] = useState(props.title);\r\n                                              should be re-evauluated, so React will execute our ExpenseItem component again and therefore re-evaulte the JSX code again. So the change will be redner onto the page when the button is clicked  \r\n\r\n      title = 'updated';                   you typically want to define a function before the return. For convention we name our function based on the relation it has. or whats it doing to makes things clear. For exmaple we named our function clickHandler \r\n                                             as this is a good way of naming a function when it is triggered upon an event. \r\n    console.log('clicked');   /* Our console.log's will show the title before it was updated as hen calling our state updating function doesnt change the value right away.         \r\n      };\r\n*/\r\n\r\n\r\n\r\n\r\n      /* JSX code below */\r\n       return (\r\n        <li>\r\n         <Card className=\"expense-item\"> \r\n\r\n            <ExpenseDate date={props.date} /> \r\n            <div className=\"expense-item__description\">\r\n              <h2>{props.title}</h2> \r\n              <div className=\"expense-item__price\">{props.amount}</div>\r\n            </div>\r\n            {/* Our goal here is when our button below is clicked we want to change the title which is being outputted on our h2 tag. Initially the title we get is the title we get through props.title but we want to change it when our button is clicked> On all built\r\n            in html elements (div, h2, button etc...) we have full acces to all native the native DOM events which we can listen to. For example, a html button element there are a bunch of events such as click and blur, and for all these default events there is a \r\n            prop equivalent in React which we can add to these built in HTML elements to listen to these events. In React we add an invent listener by going to the JSX element like our button and there we add a special prop, but now its not a prop that sets a value\r\n            for this button but instead its a props that starts with 'on' asReact exposes all these default events as props which start with 'on'. For example we can add onClick prop to our html button element. So what this does is adds an event listener for a click \r\n            event to our button. Now we just need to define what should happen when a click occurs and we do that by assigning a value to this click event and the value here has to be code which should be executed whe that click occurs. We would do this by creating \r\n            a function. So all these 'on' props want a function passed as a value, which is executed when this click occurs   */}\r\n        {/*    <button onClick={clickHandler}>Change title</button>   We now would point to our eventHandler function inside our React syntax of {} for our onClick prop and this is how we can add event listeners to our event elements.  \r\n                                                                      Just make sure that the prop event name after on starts with a uppercase like our onClick prop. */}\r\n         </Card>\r\n         </li>\r\n         );\r\n       }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nexport default ExpenseItem","import ExpenseItem from \"./ExpenseItem\";\r\nimport './ExpensesList.css';\r\n\r\n\r\nconst ExpensesList = props => {\r\n // let expensesContent = <p>No expenses found.</p>;   \r\n\r\n  // We will handle our if statement alittle bit differently now \r\n  // We will check if props.items.length === 0 (so if we have no items), and if thats the case we will return a totaly different jsx snippet as this is yet another way of handling conditional content, f what your vomponent returns changes entirely based on different conditions we can use this approach\r\n\r\n  if (props.items.length === 0 ) {\r\n    return <h2 className=\"expenses-list__fallback\">Found no expenses.</h2>\r\n  } \r\n\r\n\r\n/*\r\n  if (props.items.length > 0) { // filteredExpenses no longer exists here so we just want to get lets say our itemss/ expeses as props \r\n    expensesContent = props.items.map( expense => \r\n      <ExpenseItem \r\n        key={expense.id}\r\n        title={expense.title} \r\n        amount={expense.amount} \r\n        date={expense.date} \r\n      />\r\n  )};\r\n*/\r\n\r\n  return <ul className=\"expenses-list\" > {/* inside of this unordered list we want to output our map (line 9-14) and render it dynamically */}\r\n    {props.items.map( expense => \r\n      <ExpenseItem \r\n        key={expense.id}\r\n        title={expense.title} \r\n        amount={expense.amount} \r\n        date={expense.date} \r\n      />\r\n  )}\r\n  </ul>\r\n};\r\n\r\nexport default ExpensesList;","import './ChartBar.css';\r\n\r\nconst ChartBar = props => { // we will need props as our argument as we are already defining props in our Chart component.\r\n  let barFillHeight = '0%'; // we're setting it as a text as it will be set as a css style \r\n\r\n  if (props.maxValue > 0) { // if we do have a max value greater then 0 then this if statement will be carried out\r\n    barFillHeight = Math.round((props.value / props.maxValue) * 100) + '%'; // this will give us the percentage between 0 and 100 by which this bar should be filled, and we are roudning to the nearest interger with .round. We also want to convert this into a string with a percentage sign at the end. \r\n  }\r\n\r\n  return(\r\n    <div className=\"chart-bar\">\r\n      <div className=\"chart-bar__inner\">\r\n        <div                                    /* the height of this fill bar is missing from the css class. the amount of fill of the bar is dependent on the data we're recieving.\r\n                                                    Now we want to set barFillHeight as the css style height for this div with the \"chart-bar__fill\" class name. \r\n                                                    So we are going to set the style of this div element dynamically and that can be done by adding the style prop, which  is a default html attribute, but this style prop reacts abit differently when working within a React application, where style wants an object:\r\n                                                    style = {{}} so its got the outter curly brackets for outputting something dynamically and a inner curly bracket for an object. The style prop wants a js object as a value and we can set height to barFillHeight     */\r\n          className=\"chart-bar__fill\" \r\n          style={{height: barFillHeight}}\r\n        ></div>                                 \r\n      </div>\r\n      <div className=\"chart-bar__label\">{props.label}</div>\r\n    </div>\r\n)};\r\n\r\nexport default ChartBar;","import ChartBar from \"./ChartBar\";\r\nimport './Chart.css';\r\n\r\n\r\n/* Now in the chart we want to render all the chart bars so in our Chart component below we want to return all these chart bars in our JSX code and inside of the div (line 9) we want the bars, and we could just just render 12 ChartBare components for the 12 months that we have but we will cde a more flexiable\r\n   chart which wont be restricted to months and 12 data points. \r\n   Innstead when the Chart component is being used somewhere in our application we want to recieve the data points that should be plotted as props so that the Chart component is fairly configurable and the components that use the Chart component can decide how many data points with which value should be\r\n   rendered and therefore we will output our ChartBars dynamically (line 13) by going through an array of data points and mapping every data point to a ChartBar which is what we learnt in this module how we output lists of content dynamically. (line 13) So on our props we could expect our dataPoints prop \r\n   (this dataPoints prop can be named anything) and we expect the dataPoints props to hold an array hence we can call .map() on that and then we map every single dataPoint into a Chart bar:.map(dataPoint => <ChartBar />) so that we create as many ChartBar's as we have data points and then we want to pass some \r\n   data into the ChartBar to control how it'll be rendered, so which value would be rendered there and for that we want to extract some data from the incoming dataPoint.\r\n   Now up to this point we are never using the Chart component so we as the creature of this Chart component can define which kind of data (dataPoint) we expect to extract there in the future and for example the ChartBar component should receive a value prop and there we want to pass dataPoint.value and this \r\n   will require in the ChartBar we then read the prop (value) and that when we define dataPoints later that every dataPoint has a value (dataPoint.value) so that a dataPoint is an object which has a value property, thats what we're defining now since that is how we want to that Chart compoennt and the \r\n   ChartBar component in there.\r\n   Now we also want to make sure that every ChartBar plots the value in relation to the maximum value in the entire chart, therefore we want to pass in a maxValue property which is currently null, which isnt data that we extract from the dataPoint becuase that is a unique value which is the same for all \r\n   ChartBar's in a given Chart so we will need to derive this maxValue and we will do this later, for the moment we'll set this to null which is just a tempoary value. \r\n   We would want to have a label for example to have a label of jan, feb, mar etc. and therefore we will add in a label prop and pass in dataPoint.label (line 26).\r\n   Since we are mapping our props.dataPoints we are outputting a list here we should also add a key as we learnt that this key prop helps React render these list items efficently and therefore we do expect that every dataPoint has a unique id or we could use label as the label should be unqie and every \r\n   ChartBar has it's own unqie label and therefore we can also use the label as a unqiue identifyer for the special key prop.\r\n   Now we want to work on the ChartBar to bring that to life.        */\r\n\r\nconst Chart = props => {\r\n  const dataPointValues = props.dataPoints.map(dataPoint => dataPoint.value);\r\n  const totalMaximum = Math.max(...dataPointValues); // since the max() method wants a lists of arguments instead od an array like we have in dataPointValues we can use the spread oerator (...) to pull out all the array elements and add them as stand alone arguments to the max() method so this max(0 method will recieve 12 arguments which are these 12 values from our array pulled out by the spread operator m(...)\r\n\r\n  return( \r\n    <div className=\"chart\">\r\n      {props.dataPoints.map(dataPoint => (\r\n      <ChartBar\r\n        key={dataPoint.label}\r\n        value={dataPoint.value}\r\n       /* maxValue={null} */ \r\n        maxValue={totalMaximum} //So now we pass the totalMaximum we pass in maxValue\r\n        label={dataPoint.label}\r\n      />\r\n    ))}\r\n    </div>\r\n)};\r\n\r\nexport default Chart;","import Chart from '../Chart/Chart';\r\n\r\nconst ExpensesChart = props => {\r\n  const chartDataPoints = [\r\n    { label: 'Jan', value: 0 },\r\n    { label: 'Feb', value: 0 },\r\n    { label: 'Mar', value: 0 },\r\n    { label: 'Apr', value: 0 },\r\n    { label: 'May', value: 0 },\r\n    { label: 'Jun', value: 0 },\r\n    { label: 'Jul', value: 0 },\r\n    { label: 'Aug', value: 0 },\r\n    { label: 'Sep', value: 0 },\r\n    { label: 'Oct', value: 0 },\r\n    { label: 'Nov', value: 0 },\r\n    { label: 'Dec', value: 0 }\r\n  ];\r\n\r\n  for (const expense of props.expenses) { // we use of insead of in as we are working with with props.expenses which is an array not an object\r\n    const expenseMonth = expense.date.getMonth(); // starting at 0, January has an index of 0\r\n    chartDataPoints[expenseMonth].value += expense.amount; //The addition assignment operator ( += ) adds the value of the right operand to a variable and assigns the result to the variable.\r\n  }\r\n\r\n  return(\r\n    <Chart \r\n      dataPoints={chartDataPoints}/>\r\n)};\r\n\r\nexport default ExpensesChart;","import React, {useState} from 'react';\r\n\r\nimport './Expenses.css';\r\nimport Card from '../UI/Card'; /* So here we use ../ as we are ging up one level (out of the Expense folder and into the other sub folder of the compoement folder which would be the UI folder) */\r\nimport ExpensesFilter from './ExpensesFilter';\r\nimport ExpensesList from './ExpensesList';\r\nimport ExpensesChart from './ExpensesChart';\r\n\r\n\r\n\r\n\r\nconst Expenses = props => {\r\n  const [filteredYear, setFilteredYear] = useState('2020');\r\n\r\n  const filteredChangeHandler = selectedYear => {\r\n    setFilteredYear(selectedYear);\r\n  };\r\n\r\n  const filteredExpenses = props.items.filter(expense => {\r\n    return expense.date.getFullYear().toString() === filteredYear;\r\n    \r\n  });\r\n\r\n /* let expensesContent = <p>No expenses found.</p>; // We can stre JSX content in variables, and we are doing this so we can add a if check before our return  \r\n  if (filteredExpenses.length > 0) { // Now we can check if filteredExpense is greater then 0 and if it is expensesContent will be overridden by the result of our mapp call \r\n    expensesContent = filteredExpenses.map(expense =>\r\n      <ExpenseItem \r\n        key={expense.id}\r\n        title={expense.title} \r\n        amount={expense.amount} \r\n        date={expense.date} \r\n      />\r\n)}\r\n  */\r\n\r\n  return (\r\n    <div>\r\n      <Card className=\"expenses\">\r\n        <ExpensesFilter \r\n          selected={filteredYear} \r\n          onChangeFiltered={filteredChangeHandler} \r\n        />\r\n\r\n        <ExpensesChart expenses={filteredExpenses}/>\r\n\r\n       {/* {expensesContent}  We are adding a simple dynamic expression pointing to expensesContent, which would hold (line 23 or line 24-31) depending on which statement is true.\r\n                              This way our logic is in the component it-self and our JSX code is leaner.\r\n                              As we are moving our expensesContent  ode from this file to our new file named ExpensesList.js, we want to call the ExpensesList component instead of dynamically calling expensesContent  */}\r\n        <ExpensesList items={filteredExpenses}/> {/* So now te filteredExpenses should be passed through the item prop (we changed filteredExpenses to props.items in ExpensesList) */}\r\n\r\n    {/*    {props.items.map(expense => */}\r\n  {/*}   {filteredExpenses.map(expense =>     We are putting the reult of this map call in an if statement before our JSX code which is called outputting conitional content  \r\n          <ExpenseItem \r\n            key={expense.id}\r\n            title={expense.title} \r\n            amount={expense.amount} \r\n            date={expense.date} \r\n          />\r\n  )} */}\r\n    {/*    <ExpenseItem                         Now we can get rid of these hard coded ExpenseItems, so we wil only be left with the map expression (line 22-26), where we transformed our array (expense) to an array full of JSX items (line 23-26), so now our array is being rendered dynamicaly which simply \r\n                                                means its based on the actuale array and that means we can change our array and such changes would be reflected in our list \r\n          title={props.items[0].title}\r\n          amount={props.items[0].amount}\r\n          date={props.items[0].date}\r\n        />\r\n        <ExpenseItem\r\n          title={props.items[1].title}\r\n          amount={props.items[1].amount}\r\n          date={props.items[1].date}\r\n        />\r\n        <ExpenseItem\r\n          title={props.items[2].title}\r\n          amount={props.items[2].amount}\r\n          date={props.items[2].date}\r\n        />\r\n        <ExpenseItem\r\n          title={props.items[3].title}\r\n          amount={props.items[3].amount}\r\n          date={props.items[3].date}\r\n        /> */}\r\n      </Card>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Expenses;","import React, { useState } from 'react'; // as we are using states so we need to import like this \r\nimport './ExpenseForm.css'\r\n\r\n\r\nconst ExpenseForm = (props) => { //(...2-continued) we now expect to get some props, as we are setting a prop now (our custom prop in NewExpense.js), so we put props in our ()\r\n   // eslint-disable-next-line\r\n  const [eneteredTitle, setEnteredTitle] = useState('');  /* We are managing multiple states. You can have multiple states per component an all these states inside of the same component will be seperate from eachother  */\r\n   // eslint-disable-next-line\r\n  const [eneteredAmount, setEnteredAmount] = useState(''); /* We can update and read them individually so they work from a totally seperate way, as when we update the amount this wont affect the title or the date  */\r\n   // eslint-disable-next-line\r\n  const [eneteredDate, setEnteredDate] = useState('');    /* We are storing string '' all the time in out useState() and not a number as by defualt whenever you listen to the change event for an input: onChange={} if you read the value of the input \r\n    //                                                         element  e.g. setEneteredAmount(event.target.value); it will always be a string even if it stores a number, it will be a number as a string. This is why we always initialse all states with a string.   */\r\n\r\n/* We can also go for one state instead of three states, we do this by having one state with an object instead of a string: useState({}); and in this object we can group together our 3 states, like below and the logic is kind of the same but it is in one state object\r\nmanaged as one peice of state instead of 3 seperate slices like the code above the differance now is that whenever you update this state you need to update all three properties not just one. So we decontruct our state into an array \r\n // eslint-disable-next-line\r\n  const [userInput, setUserInput] = useState({ // We dont user userInput in our code here so we write: // eslint-disable-next-line before this code to prevent warnings coming in our terminal.\r\n    enteredTitle: '',\r\n    enteredAmount:'',\r\n    enteredDate: ''\r\n  }); */\r\n\r\n\r\n      const titleChangeHandler = event => {     /*  We named this function with Handler at the end to make it clear that this will be called on an event. you automatically get an event object which describes the event which occured: event. Automatically\r\n                                              we dont need todo anything to get this since  we passed this function to our JSX code through our onChange prop, so React will make sure we get such an event object: event when this change event occurs.\r\n                                              We can console.log this event object: console.log(event); to see whats inside it and if we start typing we get a description of the object in the console. The interesting thing in the description is the\r\n                                              target field: target: input, this target  points at the DOM element for which the event occured so in out case the input and this input element inturn has a long list of properties which we can read and\r\n                                              set but most importantly it has a value property, for example: value: 't', and tis value property holds the current of the input at the point of time this event\r\n                                              occurs (if we type t into our title input bar) and this is very useful becuase this means we can drill into the target and then the value to get the value that is currently enetered when the event occured\r\n                                              for that element for which we're listening, so now in the console we get every value for every key stroke. Look at console.log below: \r\n      \r\n      console.log(event.target.value);                                          \r\n                                                So what do we want to do with this value now. Well now we want to store it somwehre so that when the form is submitted we can use that value as we want to gather all values from all inputs and then\r\n                                                 combine them when the object is submitted and one way of storing that value and making sure it survives if the function (titleChangeHandler) would be re-executed and the component function (ExpenseForm)\r\n                                                would be re-evaluated we can use state: import Reacy, {useState} from 'react'. So we can import the state hook and call it inside and at the start of ourExpenseForm component function and set the state \r\n                                                for our inputs ( each div contain below with a className of \"new-expense__control\") and initally that is an empty string: useState(''); becuase intially when this component is rendered for the first time\r\n                                                nothing was entered but we can use destructering to get our two elemets, first elemet is the value and the second element is the calling the function which calls our first element ( which should be \r\n                                                updating the state): const [eneteredTitle, setEnteredTitle] = useState(''); (line 6).  */\r\n\r\n      setEnteredTitle(event.target.value)   /* We dont need the console.log now as when we react to the event whe the user eneters somthing we can just call setEnteredTitle() and pass event.target.value: setEnteredTitle(event.target.value); so the currently\r\n                                               entered value as a argument to setEnteredTitle(); and therefore this will be stored in our state.\r\n                                               Now we arent arent doing it to update the compoenent eventhough the component will update (that will always happen when you update the state) but we are doing it to ensure that we're storing it in some variable \r\n                                               which is kind of detachted from the lifecycle of our ExpenseForm component function, so that no matter how oftern this compoenet function might execute again this state is stored and survives. \r\n                                               There are other ways of solving this aswell but this way works just fine and it had another advantage as we will need the state for updating and for re-rendering the compnent later but for the moment we just\r\n                                               use it to save the value.  \r\n                                               \r\n                                               We will do this for the other two inputs aswell:   */                                   \r\n  };\r\n\r\n  const amountChangeHandler = event => { // We want to make sure this function gets triggered when the amount changes, so we firstly will add an onChange prop and point to our amountChangeHandler  \r\n    setEnteredAmount(event.target.value)\r\n  };\r\n\r\n  const dateChangeHandler = event  => {  // this should be trigger whenever the date changes so we will point to this with our onChange prop inside the JSX syntax {} \r\n    setEnteredDate(event.target.value)\r\n  };\r\n  \r\n\r\n  /* Below is the code where we would have one state instead of 3 sepearte one. The code above works with the way with 3 seperate states. throughout this App we will use the code above to follow the course\r\n\r\n  const titleChangeHandler = event => {  \r\n    setUserInput({                           So here we call our function setUserInput from our useState array and pass in an object where we set the eneteredTitle to event.target.value. However we need to make sure our other to peices of information dont get \r\n                                             lost (enteredAmount and enteredDate). If we just leave setUserInput with just enteredTitle (one key value) then the old state will get replaced and therefore the other two key values (enteredAmount and enteredDate)\r\n                                             would be lost.\r\n                                             So its youre responsibility to make sure the other data doesnt get lost. So you would manully need to copy the two other key values which arent updating here. \r\n                                             One way of doing this is to use the spread operator (...) and you copy in userInput: ...userInput, before the key event is called, in out case enteredTitle: event.target.value  \r\n      ...userInput,                          This takes an object (...) then pulls out all the key value pairs (userInput) and adds them to this new object and then we can still over-ride key value pairs like in out case enteredTitle and by doing this we ensure          \r\n      enteredTitle: event.target.value,      the other key value pairs arent thrown awayand used as part of the state.\r\n\r\n    })  Above is not the best way to write this code as this wont work in some cases as React schedules state updates and doesnt performe them instantly and therefore theretically if you schedule alot of state updates at the same time you could be depending on a\r\n     outdated or incorrect state snapshot if we use the above approach and if we use the approach below React will garente the state snapshot it gives you (prevState) in the inner function will always be the latest state snapshot keeping all schedule updates in mind.\r\n\r\n                                       Instead of calling it like we have done above we shoudl call it like below:  \r\n    setUserInput((prevState) => {            // We call the setUserInput function and pass in a function to it. This function which we passed through setUserInput() will automatically be executed by React and it will recieve the previous state snapshot for that state for which \r\n      return {...prevState, enteredTitle: event.target.value}; //  youre calling the updating function (the setUserInput(), the object state inside of useState({}) (line 13-17)) so we get the prevState snap shot and now inside the function we should return the new state snapshot, so this should be our object where i copy in the key value pairs\r\n                                    //  from the previous state with the spread operator (...prevState) and then we also over-ridel, in this case eneteredTitle with event.targ.value *\r\n\r\n    }); */\r\n\r\n/*\r\n  const amountChangeHandler = event => { \r\n    setUserInput((prevState) => {             \r\n      return {...prevState, enteredAmount: event.target.value};    \r\n    })\r\n  };\r\n\r\n  const dateChangeHandler = event  => {  \r\n    setUserInput((prevState) => {           \r\n      return {...prevState, enteredData: event.target.value};    \r\n    })\r\n  };\r\n*/\r\n\r\n  const submitHandler = (event) => {  /* Unfortunatly part of the defualt browser behaviour for the button and and form discussed below, is that if you do click the button the page would reload becuase the browser automatically sends a request whenever a form is submitted to the server that is hosting the webpage\r\n                                     and thats not what we want here, instead we want to handle the form submission: <form onSubmit={submitHandler}> (which is the first line of our return) with js and manually collect and combine the data and do something with it. \r\n                                     Thankfully we can prevent this behaviour becuase we again get an event object here automatically: const submitHandler = (event) => {}; just like we did for the change events and on this object we can call a preventDefualt method: event.preventDefault(); and this is built\r\n                                     into js. We can prevent the default of the request being sent and since that request is not sent the page will now also not reload becuase we stay on the current reloaded page without sending any requets anywhere and we can continue handling this with js. */\r\n    event.preventDefault();\r\n                                    \r\n    const expenseData = {             /* So then therefore now we can create our, let's say expenseData object and now combine all that entered data (line 7-11)   */\r\n      title: eneteredTitle,\r\n      amount: +eneteredAmount,\r\n      date: new Date(eneteredDate)    /* so here we construct a new date with the built in date constructor: new Date() to which we pass in the enteredDate: new Date(enteredDate) which will pass that string and convert it into a date object. \r\n                                         Now these properties names here: title, amount, date can be named anything as this is our object. These eneteredTitle, eneteredAmount, eneteredDate points at the state variables (line 7-11)  */\r\n    };\r\n    \r\n    props.onSaveExpenseData(expenseData); /* (...2-continued) Now inside of our submitHandler instead of logging our expenseData, we will access props.onSaveExpenseData(); and execute it (use ()). We can execute it becuase the value which we get on this onSaveExpenseData key will be a function as we are passing\r\n                                             in a function from NewExpense.js which will now be executed in a different component, this ExpenseForm component. \r\n                                  We can execute the function eventhough it's not defined inside of ExpenseForm becuase we are pasing a pointer: {saveExpenseDataHandler} throught the onSaveExpenseData prop, inNewExpense.js.\r\n                                  This is how you can communicate between components and how you can communicate up, and how you can make sure a child component (the ExpenseForm component in NewExpense.js file) can communicate up to the parent component (the NewExpense component, so the function named\r\n                                  NewExpense in the NewExpense.js file).\r\n                                  So we can call a function in the NewExpense component (NewExpense function in NewExpense.js file) and we can pass data: eneteredExpenseData as a parameter. So on line 107 when we call onSaveExpenseData which is in the ExpenseForm we can pass the expenseData which we \r\n                                  generate on line 100 as an argument and thats the value which we will recieve as a paramter in the NewExoense component: eneteredExpenseData.\r\n                                  The trick really is that we pass around a pointer and a fucntion. (...3-continued in NewExpense.js)*/ \r\n\r\n   // console.log(expenseData); /* So now we are able to gather our expenseData (our user input) and combine it into this object and clear the form there after (line 108-110.  */\r\n    setEnteredTitle('');      \r\n    setEnteredAmount('');\r\n    setEnteredDate('');       /* The only problem is that having this data is nice but techniqually we dont need it in the ExpenseForm component. Instead we need it in the NewExpense.js component or to be precise in the App.js component as there we have our expenses array and ultimatly our goal would be to \r\n                                 add the new expense that the user entered to the list of exsisting expneses (our array in the App function in App.js component) and we probably want to enrich it by adding an id. \r\n                                 \r\n                                 So we need to pass the data which we're collecting and generating in ExpenseForm.js to the App.js component. Up to this point we only learned how we can pass data down (so how we can for example in the Expense folder pass title, amount and date (in the Expense.js component)\r\n                                 from the Expense.js component to the ExpenseItem component, so from parent to child, which we learned we can do with props)\r\n                                 But how can we do it in the other direction, if data is generated in the ExpenseForm and then we want to pass it up to the App.js component. We actually saw how it works but it's easy to miss it.\r\n                                 In this component ExpenseForm.js we are listening to user input (look at our input elements in our JSX code below) by using the onChange prop, such as changes to the title input: onChange={titleChangeHandler} and whenever the user types there the function titleChangeHandler\r\n                                 executes and there we get this default event object (line 24) thats somthing the browser gives us. We can actually think of the input element in our JSX code as a component aswell, it's not one of our components but it is simply a pre built component we could say provided to \r\n                                 us by React and translated to the input DOM element but it has this component character in the end and we do also set some props on this element: type, value, including the special onChange prop. Now actually this onChange prop isnt that special its just a prop named on change\r\n                                 which wants a function: {titleChangeHandler}, as a value and then internally the input element adds this event listener. So React basically see's that we set a value on the onChange prop and adds that listener on the render input element. This is the pattern we can replicate \r\n                                 for our own components aswell, we can create our own event props and we can expect functions as value and that would allow us to pass a function from a parent component to a child component and then call that component inside of the child component and when we then call a \r\n                                 function we can pass data to that function as a parameter and that how we can comunicate up from child to parent  \r\n                                 \r\n                                 Let's say we want to pass the ExpensData which we gather in the ExpenseForm component to the NewExpense compoenent as the first step becuase if we ultimatly want to reach the App component we first of all have to reach the NewExpense component becuase its the NewExpense\r\n                                 component which uses the ExpenseForm component and then in the second step later its the App component which uses the NewExpense component but we can't skip components inbetween which we have learnt before.\r\n                                 Props can only be passed from parent to child we cant skip intermediate components.\r\n\r\n                                 So therefore as a first step lets make sure we can pass the expenseData (line 100) in our ExpenseForm.js component to NewExpense. (...1-continued in NewExpense.js file on line 7)  */\r\n};\r\n\r\n  return (\r\n   <form onSubmit={submitHandler}>  {/* We want to make sure that our form can be submitted when our button is pressed and that then we gather our state slices: enteredTitle, enteredAmount, enteredDate and combine them into one object which for the moment its just logged to the console but which we can use\r\n                                    for different things later and therefore we want to listen to the form being submitted.\r\n                                    We could add a click listener: onClick=\"\" in our button however this would not be the best way of listening here, becuase there is a deafult behaviour built into the browser and built into forms on webpages. If a button especially with type='submit' is pressed inside\r\n                                    of a form, the overall form element will emit an event that wecan listen to and thats the submit event: onSubmit and then execute some function: onsubmit={} whenever the form is being submitted, which we will add above our return and we will point to this function inside\r\n                                    the React syntax {}: {submitHandler} */}\r\n      <div className=\"new-expense__controls\">\r\n        <div className=\"new-expense__control\">\r\n          <label>Title</label>\r\n          <input \r\n            type='text' \r\n            value={eneteredTitle} /* After adding this value attribute out input element has two way binding, as we dont just listen to onChange in the input to update our state but we also feed the state back into the input so that when we change the state we also change the input. This might sound like a \r\n                                      infinite loop but it isnt so there wont be any problem here. But the advantages of when the form is submitted we can call setEnteredTitle and set this back to an empty string: setEnteredTitle(''); which also was our inital state and by doing that we override what the user\r\n                                      entered after the form was submitted and therefore clear the input and we can do this for all inputs (lines 108-110) and then we just add the value prop (line 124) to all our inputs respectivly. */\r\n            onChange={titleChangeHandler} /> {/* We are pointing at the function titleChangeHandler with our {} syntac for the onChange prop */}\r\n        </div>\r\n        <div className=\"new-expense__control\">\r\n          <label>Amount</label>\r\n          <input \r\n            type=\"number\" \r\n            min=\"0.01\" \r\n            step=\"0.01\" \r\n            value={eneteredAmount} /* So here add value and point at eneteredAmount, to pass that back into the amount input. */\r\n            onChange={amountChangeHandler} /> {/* We're pointing to the amountChangeHandler as the amount will change here */}\r\n        </div>\r\n        <div className=\"new-expense__control\">\r\n          <label>Date</label>\r\n          <input \r\n            type=\"date\" \r\n            min=\"2019-01-01\" \r\n            max=\"2022-12-31\" \r\n            value={eneteredDate} /* So here add value and point at eneteredDate, to pass that back into the amount input. */\r\n            onChange={dateChangeHandler} /> {/* We are setting a min and max as later we want to add a filter where we only provide dates from 2019-2022.\r\n                                                                                                   We're also pointing to the dateChangeHandler function as here is where the date will change */}\r\n        </div>\r\n      </div>\r\n      <div className=\"new-expense__actions\">\r\n        <button type=\"button\" onClick={props.onCancel}>Cancel</button>\r\n        <button type=\"submit\">Add Expense</button> {/* We need a button to submit the form (the stuff inside of our form tag in out JSX code). Since it;s inside of our form taf once the button is clicked our form will be submitted */}\r\n      </div> \r\n  </form>\r\n  );\r\n};\r\n\r\nexport default ExpenseForm;","import React, { useState } from 'react';\r\n\r\nimport './NewExpense.css';\r\nimport ExpenseForm from './ExpenseForm'\r\n\r\nconst NewExpense = (props) => { // (...5-continued) We can accept the props argument/paramter here  \r\n  const [isEdiiting, setIsEditing] = useState(false);\r\n\r\n  const onSaveExpenseDataHandler = (eneteredExpenseData) => { /* As a parameter here i will expect the eneteredExpenseData, the name of the paramter is upto us it's our function but now we make it clear that this function expects to get this parameter   */\r\n    const expenseData = {        \r\n      ...eneteredExpenseData,         /* here we copy in our expenseData which we expect to be the object that we generate in ExpenseForm.js (Line 94-110), in the submitHandler so the object named expenseData (in ExpenseForm.js, Line 100-103). So i pull out all the key value pairs and pass them into this new object: enteredExpenseData */\r\n      id: Math.random().toString()    /* and we pass in a new key (the id key) and simply set this to Math.random().toString() (isnt the best id key but its good enough for this)*/\r\n    };\r\n  //  console.log(expenseData);  and then we can see what we do then there-after, so for the moment we will just log this enriched expenseData.   \r\n    props.onAddExpense(expenseData); //(...5-continued) We are calling the function that is passed as a value for that onAddExpense prop in App.js (line 78) and we will forward our enriched expenseData\r\n  setIsEditing(false);\r\n  };\r\n\r\n/*  (..3-continued) Now we can continue in this chain. We can communicate up from inside NewExpense tp App.js as it's this App compoenent that needs this NewExpense in the end to add it to the expenses array (line 7-30 in App.js) (...4-continued on App.js) */\r\n\r\nconst startEditingHandler = () => {\r\n  setIsEditing(true);\r\n}\r\n\r\nconst stopEditingHandler = () => {\r\n  setIsEditing(false);\r\n}\r\n\r\n  return ( \r\n  <div className =\"new-expense\">\r\n    {!isEdiiting && <button onClick={startEditingHandler}>Add New Expense</button>}\r\n    {isEdiiting && <ExpenseForm onSaveExpenseData={onSaveExpenseDataHandler} onCancel={stopEditingHandler} />} {/* (...1-continued) We can do this by adding a new-prop to ExpenseForm. It's our component so we can name it however we want but we will name it: onSaveExpenseData, we are naming it with on first becuase we want to make it clear that the value for this prop \r\n                                                                     should be a function which will eventually be triggered when somthign happens inside of this ExpenseForm component: ExpernseForm... In our case when the user saves the entered expense data, so when the form is submitted in the end.\r\n                                          We just do start with on to follow this convention and to make it clear that the value for this prop should be a function which can then be called inside of the ExpenseForm component, hence it's a function we should define here in NewExpense (just as we did it for\r\n                                          the input elements with the functions we've bound to the onChange prop, we defined those in the ExpenseForm.js file before we returned our JSX code.)\r\n                                          Now we're doing the same here one level above in the NewExpense component for our own custom ExpenseForm component (line 7). \r\n                                          \r\n                                          Now the function onSaveExpenseDataHandler is a pointer which we want to pass as a value for our prop for the ExpenseForm componenet: onSaveExpenseData={onSaveExpenseDataHandler}, so that this onSaveExpenseDataHandler prop in our custom component recieves the function\r\n                                          named onSaveExpenseDataHandler (line 5-11) as a value, as we are just pointing at the fuction, (it's being executed above, line 5-11) so that the function itself is passed to ExpenseForm.\r\n                                          Now this is the first step, the second step is to use this function inside our custom component, thats the step we didnt have to do for the inputs in ExpenseForm.js as they we're built in components. However there also we pass onChange and internally React then\r\n                                          will add a listener and then call the function which we pass in (e.g. in ExpenseForm.js we have onChange={titleChangeHandler so we pass in titleChangeHandler} whenever that event occurs, the onChange event).\r\n\r\n                                          Now since we're doing it on our own custom component we also have to call the passed in function manually (onSaveExpenseDataHandler) and this is what we'll do next. \r\n                                          So inside of ExpenseForm.js we can now expect the onSaveExpenseData prop as we are setting it when we use the ExoenseForm component hence inside of ExpenseForm.js we can extract this value passed in for this prop ie. this function: onSaveExpenseDataHandler \r\n                                          (...2-continued in ExpenseForm.js)*/}\r\n  </div>\r\n  );\r\n};\r\n\r\nexport default NewExpense;","import React, {useState} from 'react';\nimport Expenses from \"./components/Expenses/Expenses\";\nimport NewExpense from \"./components/NewExpense/NewExpense\";\n/* import ExpenseItem from './components/ExpenseItem';  We import it like this as ExpenseItem is in a different folder to this main App.js component  */\n\nconst Dummy_expenses = [\n  {\n    id: 'e1',\n    title: 'Toilet Paper',\n    amount: 94.12,\n    date: new Date(2020, 7, 14),\n  },\n  { id: 'e2', \n    title: 'New TV', \n    amount: 799.49, \n    date: new Date(2021, 2, 12) },\n  {\n    id: 'e3',\n    title: 'Car Insurance',\n    amount: 294.67,\n    date: new Date(2021, 2, 28),\n  },\n  {\n    id: 'e4',\n    title: 'New Desk (Wooden)',\n    amount: 450,\n    date: new Date(2021, 5, 12),\n  },\n];\n\nconst App = () => {\n  const [expenses, setExpenses] = useState(Dummy_expenses); // we are passing the dummy_expenses as an inital state value. We also use destrutering to get access to our expenses and our state updating function. \n\n\n\n\n\n  const addExpenseHandler = expense => {  /*(...4-continued) We can add a function which we define before we return JSX code, we can name our function lets say addExpenseHandler and we can expect to get expense as our parameter and then we do somthing with it  */\n\n    setExpenses((prevExpenses) => {       /* We are updating our state depending on the previous state, we should use this special function form for this state updating function, so we pass a function as an argument to this state updating function and that function will automatically recieve the latest state snapshot,\n                                             so we would get our prevous state automantically by React (prevExpenses)  */\n      return [expense, ...prevExpenses];  /* And we would return our new array where we would add our expense which we are getting as a parameter in line 38 and then we would add out prevExpenses with the spread operator and this is the clean way of updating our array when its based of an older snapshot of \n                                             that same state.\n                                             Now with that we add our new expense and now since we're using our expense state on line 90 to pass it to expenses we shoud automatically have a dynamic ist which should update when items are added  */\n    });                   \n  };\n/*\n  return (\n    <div>\n      <h2>Let's get started!</h2>\n\n\n{/* This is how you reuse components below. We want to pass the data of these different objects in the array expenses to these different expense items, which means we want to make these expense items configurable from outside. The data should \nnot be stored inside of them but instead recieved from outside and that works with the props concept.\nWe can simply add attributes to these custom html elements (our components). \nWe can dymanically retrive the title expense item, and we can do this by using the {} syntac. So we would use {} to assign values to attributes.\ntitle={expenses[0].title} Here we accessed expenses which is our array and [0] is the first item with index 0, and then we access the property title. Our attribute name of title can be anything but i named it title as it makes sense to as we \nare trying to grab title from our array with index 0. Make sure the coede after the dor (.) matches the properties name in our object in the array.\nIf you have a component that has no content between the opening and closing tags like: <ExpenseDate></ExpenseDate> we can write it like we have, a self closing element \n      <ExpenseItem title={expenses[0].title}      \n                   amount={expenses[0].amount}\n                   date={expenses[0].date}\n      /> \n      <ExpenseItem title={expenses[1].title}       \n                   amount={expenses[1].amount}\n                   date={expenses[1].date}\n      /> \n      <ExpenseItem title={expenses[2].title}      \n                   amount={expenses[2].amount}\n                   date={expenses[2].date}\n      /> \n      <ExpenseItem title={expenses[3].title}      \n                   amount={expenses[3].amount}\n                   date={expenses[3].date}\n      /> \n\nNow after coding the above we have only coded the first half of what we need to do. Above we added the attributes: title, amount, data which can be any names of our choice as ExpenseItem are our custom elements, but inside of the ExpenseItem.js component file\nwe need to do somthing with these recieved arrtibute values and thats the half that is missing.  \n    </div>\n  );\n} */\n\n\n  return (\n    <div>\n      <NewExpense onAddExpense={addExpenseHandler}/> {/*(...4-continued) Now we do the same thing as we did previiucly we add a pointer at the function addExpenseHandler, we just created (line 35) to NewExpense so that inside of NewExpense we can call this function and pass the expense data \n                                                        (our paramter in line 35) up the App component. So we could name this prop here onAddExpense, keep in mind we can name it anything but again we will follow the convention of starting with on, to make it clear that it is a function pointer which\n                                                        is passed as an argument, and then we pass a pointer at addExpenseHandler to the onAddExpense prop to the NewExpense and therefore inside of NewExpense component in NewExpense.js we can now call that(...5-continued in NewExpense.js)    */}\n\n      <Expenses items={expenses}/> {/* so here we are saying in our Expenses component file (Expenses.js) our item is our function expenses on our App component file (App.js)*/}\n    </div>\n  );\n  }\nexport default App;\n","import ReactDOM from 'react-dom/client';\n\nimport './index.css';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n"],"sourceRoot":""}